import math
import torch
import torch.nn as nn
import torchvision


class spatial_pyramid_pool(torch.nn.Module):
    """
    out_pool_size: a int vector of expected output size of max pooling layer
    returns: a tensor vector with shape [1 x n] is the concentration of multi-level pooling
    """
    def __init__(self, out_pool_size, pooltype='max_pool'):
        super(spatial_pyramid_pool, self).__init__()
        self.out_pool_size = out_pool_size
        self.pooltype = pooltype

    def forward(self, x):
        num, c, h, w = x.size()
        for i in range(len(self.out_pool_size)):
            # if self.out_pool_size[i] == 4 and x.shape[2] % 2 == 1:
            #     # 如果第三个维度是奇数，添加一行全零的填充
            #     padding = torch.zeros(x.shape[0], x.shape[1], 1, x.shape[3]).to('cuda')
            #     x = torch.cat((x, padding), dim=2)
            # 依据输入的feature map和 期望输出的值个数 调整pooling的尺寸 以及padding的尺寸
            h_wid = int(torch.ceil(torch.true_divide(h,  self.out_pool_size[i])))
            w_wid = int(torch.ceil(torch.true_divide(w,  self.out_pool_size[i])))
            h_pad = math.floor((h_wid * self.out_pool_size[i] - h + 1) / 2)
            w_pad = math.floor((w_wid * self.out_pool_size[i] - w + 1) / 2)
            padding = (h_pad, w_pad)
            # update input data with padding
            #  class torch.nn.ZeroPad2d(padding)[source]
            #
            #     Pads the input tensor boundaries with zero.
            #
            #     For N`d-padding, use :func:`torch.nn.functional.pad().
            #     Parameters:   padding (int, tuple) – the size of the padding. If is int, uses the same padding in all boundaries.
            # If a 4-tuple, uses (paddingLeft, paddingRight, paddingTop, paddingBottom)
            zero_pad = torch.nn.ZeroPad2d((padding[1], padding[1], padding[0], padding[0]))
            x_new = zero_pad(x)
            # update kernel and stride
            h_new, w_new = x_new.size()[2:]
            kernel_size = (math.ceil(h_new / self.out_pool_size[i]), math.ceil(w_new / self.out_pool_size[i]))
            stride = (math.floor(h_new / self.out_pool_size[i]), math.floor(w_new / self.out_pool_size[i]))
            maxpool = nn.MaxPool2d(kernel_size, stride=stride)
            x1 = maxpool(x_new)
            if (i == 0):
                spp = x1.view(num, -1)
            else:
                spp = torch.cat((spp, x1.view(num, -1)), 1)
        return spp


if __name__ == "__main__":
    spp = spatial_pyramid_pool(out_pool_size=[1, 2, 4])
    # 使用 torch.randn 生成一个随机张量，可以根据需要替换成其他数据
    tensor = torch.randn(32, 512, 6, 500)
    spp1 = spp(tensor)
    print(spp1)

