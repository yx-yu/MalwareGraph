# -*- coding: <encoding> -*-

import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.manifold import TSNE


def set_matplotlib_fonts(font_name):
    # 通过该函数设置 Matplotlib 中的字体为新罗马字体
    plt.rcParams['font.family'] = font_name


def plot_confusion_matrix(confusion_matrix, classes, normalize=False, cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if normalize:
        confusion_matrix = confusion_matrix.astype('float') / confusion_matrix.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    plt.imshow(confusion_matrix, interpolation='nearest', cmap=cmap)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=0)
    plt.yticks(tick_marks, classes)

    fmt = '.2f' if normalize else '.0f'
    thresh = confusion_matrix.max() / 2.
    for i in range(confusion_matrix.shape[0]):
        for j in range(confusion_matrix.shape[1]):
            plt.text(j, i, format(confusion_matrix[i, j], fmt),
                     ha="center", va="center",
                     color="white" if confusion_matrix[i, j] > thresh else "black")

    plt.xlabel('Predicted label')
    plt.ylabel('True label')
    plt.tight_layout()



def plot_matrix(confusion_matrix, classes):
    # 设置字体为新罗马字体
    # set_matplotlib_fonts('Times New Roman')
    plt.figure()
    plot_confusion_matrix(confusion_matrix, classes, normalize=False, cmap=plt.cm.Blues)
    # 绘制混淆矩阵（不进行归一化）
    # plot_confusion_matrix(confusion_matrix, classes, normalize=False, title='Confusion Matrix (without normalization)')
    # 绘制归一化后的混淆矩阵
    # plot_confusion_matrix(confusion_matrix, classes, normalize=True, title='Normalized Confusion Matrix')
    plt.savefig('matrix.pdf', format="pdf")
    plt.show()


def plot_embedding(data, label, title):
	"""
	:param data:数据集
	:param label:样本标签
	:param title:图像标题
	:return:图像
	"""
	x_min, x_max = np.min(data, 0), np.max(data, 0)
	data = (data - x_min) / (x_max - x_min)		# 对数据进行归一化处理
	fig = plt.figure()		# 创建图形实例
	ax = plt.subplot(111)		# 创建子图
	# 遍历所有样本
	for i in range(data.shape[0]):
		# 在图中为每个数据点画出标签
		plt.text(data[i, 0], data[i, 1], str(label[i]), color=plt.cm.Set1(label[i] / 10),
				 fontdict={'weight': 'bold', 'size': 7})
	plt.xticks()		# 指定坐标的刻度
	plt.yticks()
	plt.title(title, fontsize=14)
	# 返回值
	return fig


# 主函数，执行t-SNE降维
def t_sne(data, label):
	print('Starting compute t-SNE Embedding...')
	ts = TSNE(n_components=2, init='pca', random_state=0)
	# t-SNE降维
	result = ts.fit_transform(data)
	# 调用函数，绘制图像
	fig = plot_embedding(result, label, 't-SNE Embedding of digits')
	# 显示图像
	plt.savefig('plot.pdf', format="pdf")
	plt.show()

